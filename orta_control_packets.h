#ifndef __CONTROL_PACKET_TYPES
#define __CONTROL_PACKET_TYPES

#include <sys/time.h>
#include <time.h>

#include <arpa/inet.h>  /* struct sockaddr_in */

/* FIXME: Pretty arbitrary */
#define PACKET_SIZE 1048576

/**
 * Packet types.
 * * join: Member is requesting to join a group.
 * * refresh: Body of packet contains details of known group members and 
 *     distances to those members, for use with routing algorithms.
 * * leave: Member is leaving the group.
 * * ping_request: A ping request.
 * * ping_response: A ping response.
 */
enum control_type {
	/* Packet types for initiating control operations */
	join, 
	join_ok, 
	join_deny, 

	req_add_link, 
	req_add_link_ok, 
	req_add_link_deny, 

	/* Packet types used for the flooding of information */
	/*flood_member_join, */
	flood_new_link, 
	flood_drop_links, 
	flood_member_leave, 
	flood_refresh, 

	/* Packet types used on the UDP side of things */
	ping_request, 
	ping_response, 

	data, 
};


/**
 * packet_header acts as a convenient (ie: readable) way of grabbing the type 
 * of incoming control packet; the packet can then be cast to the appropriate 
 * type afterward.
 */
typedef struct _control_packet_header
{
	enum control_type type;
	uint32_t source_ip;
	uint32_t seq;
} control_packet_header_t;


/**
 * ping_packet.
 * 
 * Same packet type can be used for ping_req, and ping_resp; all that the 
 * ping response should really do is change the header type and return the 
 * packet.
 */
typedef struct _ping_packet
{
	control_packet_header_t header;
	struct timeval time;
} ping_packet_t;


/**
 * One data segment for a refresh packet:
 * * The host's IP;
 * * The host's last known sequence number;
 * * The overlay distance to that host.
 */
typedef struct _link_data
{
	uint32_t from;
	uint32_t to;
	uint32_t weight;
} link_data_t;

typedef struct _refresh_data
{
	uint32_t to;
	uint32_t weight;
} refresh_data_t;


typedef struct _link_name
{
	uint32_t from;
	uint32_t to;
} link_name_t;


/**
 * Intention is that a refresh packet consists of a header, and a block of 
 * memory holding 1 or more control data structs. This is reasonable, as 
 * the control data sent will include the address for the localhost too.
 * * seq: sequence number for the packet.
 * * count: Number of data segments contained within the packet.
 * * *data: Pointer to the data itself.
 */
typedef struct _refresh_packet
{
	control_packet_header_t header;
	uint32_t link_count;
	refresh_data_t data;
} refresh_packet_t;

typedef struct _member_data
{
	uint32_t ip_addr;
} member_data_t;


typedef struct _join_ok_packet
{
	control_packet_header_t header;
	uint32_t member_count;
	uint32_t link_count;
	member_data_t data;
} join_ok_packet_t;



/**
 * Packet type flood_member_join contains enough information to add the new 
 * member + the new link (remembering the link is a->b AND b->a).
 */
/* typedef struct _flood_member_join */
/* { */
/* 	control_packet_header_t header; */
/* 	uint32_t existing_member_ip; /\* To set up link state... *\/ */
/* 	uint32_t link_weight; */
/* } flood_member_join_t; */


/**
 * Packet type flood_add_link carries information about one new link
 * in the overlay.
 */
typedef struct _flood_new_link
{
	control_packet_header_t header;
	uint32_t to;
	uint32_t weight;
} flood_new_link_t;

/**
 * Packet type flood_drop_links carries information about one or more
 * dead link in the overlay.
 */
typedef struct _flood_drop_links
{
	control_packet_header_t header;
	uint32_t link_count;
	link_name_t data;
} flood_drop_links_t;

/**
 * Packet type flood_member_leave removes one member from the overlay.
 * This packet can be generated by a host leaving, or also by an
 * attempt to fix a broken overlay realising that the host is dead.
 */
typedef struct _flood_member_leave
{
	control_packet_header_t header;
	uint32_t member; /* Member which has left the group */
	uint32_t link_count;
	link_name_t data;
} flood_member_leave_t;

#endif

